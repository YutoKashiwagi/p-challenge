## 質問3

## なぜ元の関数はカバレッジ100%のテストを書けなかったか
  - NameApiServiceに関して
    - 実際のAPIに依存した設計になっており、APIが返した値による分岐が網羅できていなかった
  - asyncSumOfArraySometimesZeroに関して
    - 依存しているDBクライアントのクラス側で時々処理が失敗するようになっていたため、成功と失敗の分岐網羅ができていなかった

## 依存性の注入について
 - オブジェクトAが別のオブジェクトBに依存している時、Aの中でBを直接生成するのではなく、Bを外部から注入すること。これにより実際のオブジェクトへの依存ではなく、インターフェースへの依存に変わる
  - 注入方法はコンストラクタインジェクション、セッターインジェクション、フィールドインジェクションなどがあるが、基本的にコンストラクタインジェクションで良い。[参考](https://irof.hateblo.jp/entry/2017/04/16/222737)
- どんな問題を解決するか？
  - 疎結合になり、オブジェクトの責務と依存箇所が明確になる。これにより、テストもしやすくなる
    - 継承を使った場合と比較すると、依存箇所が明確になることのメリットがわかりやすい

## 依存性の注入と結合度
- 内容結合からデータ結合へと変化し、結合度が下がった

## 単体テスト中に外部サービスとの通信が発生する際のデメリット

- 外部サービスに障害が発生した場合、単体テストが落ちてしまう
  - 外部サービスとの通信のテストは、ヘルスチェックで担保するのが望ましい
- rate-limitに引っかかる可能性がある
- そのサービスに余計な負荷がかかる
- 外部との通信が発生するため、テストが遅くなる
  - 開発者の長期的なストレスの原因になる
